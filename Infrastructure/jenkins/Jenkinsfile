import groovy.transform.Field

@Field
Map FAILED_STAGES = [:]  // Global map to keep track of stage results and error messages

// Function to run a stage and capture its result and any error message
def runTest(String stageName, Closure body) {
    //build result will stay success even if a stage fails- for graceful failing. Have a stage fail without build fail.
    catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
        try {
            body()  // Execute the stage's steps
        } catch (e) {
            // Capture the stage name and error message in the global map if it fails
            FAILED_STAGES["${stageName}"] = "FAILED: ${e.message}"
            throw e //  the error to mark the stage as failed
        }
    }
}


pipeline {
    agent {
        kubernetes {
            inheritFrom 'jenkins-runner'
            yamlFile 'Infrastructure/jenkins/runner.yaml'
            defaultContainer 'builder'
        }
    }
    environment {
        DOCKERHUB_CREDENTIALS = 'docker-cred'
        GITHUB_CREDENTIALS = 'github-token'
        REPO_URL = 'https://github.com/noa-bl/FinalProject.git'
        GITHUB_REPO = 'noa-bl/FinalProject'
        DOCKER_IMAGE = 'noabl/flask-app'
        TEST_IMAGE = 'noabl/flask-test'
        APPLICATION_DIR = 'Application'
        FEATURE_BRANCH = 'feature'
        VERSION = 'latest'
        GITHUB_API_URL = 'https://api.github.com'
        EMAIL_RECIPIENTS = 'noablfdev@gmail.com'
        EMAIL_CREDENTIALS = credentials('email-cred')

    }
    stages {
        stage('Checkout SCM') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/feature'], [name: '*/master']], //change later
                    userRemoteConfigs: [[
                        url: "${REPO_URL}",
                        credentialsId: GITHUB_CREDENTIALS
                    ]]
                ])
            }
        }
        stage('Create External Network') {
            steps {
                    script {
                        sh 'docker network create mynetwork || true'
                    }
                }
            
        }
        stage('Build and Push Image for app- with temp tag') {
            steps {
                    script {
                        docker.build("${DOCKER_IMAGE}:temp", "-f ${APPLICATION_DIR}/Dockerfile ${APPLICATION_DIR}")
                        docker.withRegistry('https://index.docker.io/v1/', DOCKERHUB_CREDENTIALS) {
                            docker.image("${DOCKER_IMAGE}:temp").push()
                        }
                    }
            }
        }
                stage('Build and Push Image for test_main') {
            steps {
                    script {
                        docker.build("${TEST_IMAGE}:latest", "-f ${APPLICATION_DIR}/dockerfile.test ${APPLICATION_DIR}")
                        docker.withRegistry('https://index.docker.io/v1/', DOCKERHUB_CREDENTIALS) {
                            docker.image("${TEST_IMAGE}:latest").push()
                        }
                    }
            }
        }
        stage('Run Tests with Docker Compose') {
            steps {
                    script {
                        sh "docker-compose -f ${APPLICATION_DIR}/docker-compose.yaml up --abort-on-container-exit"
                    }
                }
            
            
        }

        //added stage: merge request when on feature branch
stage('Create Merge Request') {
    when {
        not {
            branch 'master'
        }
    }
    steps {
        withCredentials([usernamePassword(credentialsId: 'github-token', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
            script {
                def branchName = env.BRANCH_NAME
                def pullRequestTitle = "Merge ${branchName} into master"
                def pullRequestBody = "Merge request from Jenkins pipeline - branch ${branchName}"

                // Debugging statements
                echo "Branch Name: ${branchName}"
                echo "Pull Request Title: ${pullRequestTitle}"
                echo "Pull Request Body: ${pullRequestBody}"
                echo "GitHub API URL: ${GITHUB_API_URL}"
                echo "GitHub Repo: ${GITHUB_REPO}"
                echo "GitHub Username: ${USERNAME}"

                sh """
                    set -x
                    curl -X POST -u ${USERNAME}:${PASSWORD} \
                    -H "Accept: application/vnd.github.v3+json" \
                    -d '{ "title": "${pullRequestTitle}", "body": "${pullRequestBody}", "head": "${branchName}", "base": "master" }' \
                    ${GITHUB_API_URL}/repos/${GITHUB_REPO}/pulls
                    set +x
                """
            }
        }
    }
}
        //ask for merge approval 
            stage('Wait for Approval for Merge') {
                when {
                allOf{
                    not {branch 'master'}
                    expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
                    }
                
            }
            steps {
                script {
                    def userInput = input(
                        id: 'Proceed1', message: 'Approve Merge?',
                        parameters: [
                            [$class: 'BooleanParameterDefinition', defaultValue: true, description: 'Approve to merge the feature branch into master?', name: 'approve']
                        ]
                    )
                    if (userInput == false) {
                        error "Merge not approved."
                    }
                }
            }
        }

        stage('Push Final Image to DockerHub') { //only when branch is master
            when {
                allOf{
                    branch 'master'
                    expression { currentBuild.result == null || currentBuild.result == 'SUCCESS' }
                }
            }
            steps {
                    script {
                        docker.withRegistry('https://index.docker.io/v1/', DOCKERHUB_CREDENTIALS) {
                        sh "docker tag ${DOCKER_IMAaGE}:temp ${DOCKER_IMAGE}:${VERSION}"
                        sh "docker push ${DOCKER_IMAGE}:${VERSION}"
                        }
                    }
                }
            }
            //add chart stages...
    }

    post {
        failure {  // This block runs if the pipeline fails
                script {
                
                def buildNumber = currentBuild.number  // Get the current build number
                def failedStage = FAILED_STAGES.find { it.value.startsWith('FAILED') }?.key  // Get the name of the failed stage
                def errorMessage = FAILED_STAGES[failedStage]?.split(':', 2)?.getAt(1)?.trim()  // Extract only the error message

                // Construct the email subject
                def emailSubject = "Build ${buildNumber} Failed - Automatic Email"
                // Construct the email body
                def emailBody = "Build ${buildNumber} failed at stage ${failedStage}"
                if (errorMessage) {
                    emailBody += " due to: ${errorMessage}"
                }
                emailBody += "\n\nStage Results: ${FAILED_STAGES}"  // Include the stage results in the email body
                echo emailBody // Log sending email
                // Send the email with the constructed subject and body
                
            }
        }
    }
}